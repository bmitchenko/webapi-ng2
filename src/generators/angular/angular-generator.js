"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var specification_1 = require("../../specification");
var AngularGenerator = (function () {
    function AngularGenerator() {
    }
    AngularGenerator.prototype.generate = function (specification, config) {
        //         if (apiDescription.definitions != undefined) {
        //             this.mapDefinitions(apiDescription.definitions);
        //         }
        var script = this.getHeader() + '\n\r' +
            this.getImports() + '\n\r' +
            this.getOptions() + '\n\r' +
            this.getBaseClass(config) + '\n\r';
        for (var _i = 0, _a = specification.controllers; _i < _a.length; _i++) {
            var controller = _a[_i];
            script += '\n\r' + this.getController(controller, config);
        }
        if (specification.schema != undefined) {
            for (var schemaName in specification.schema) {
                var schema = specification.schema[schemaName];
                script += '\n\r' + this.getSchema(schema);
            }
        }
        return script;
    };
    AngularGenerator.prototype.getHeader = function () {
        var result = "\n            // \n            // This file is autogenerated. \n            // See http://github.com/bmitchenko/webapi-ng2 for details. \n            //        \n        ";
        return result;
    };
    AngularGenerator.prototype.getImports = function () {
        var result = "\n            import { Injectable } from '@angular/core';\n            import { Http, ResponseContentType, URLSearchParams } from '@angular/http';\n            import { Observable } from 'rxjs';\n            import 'rxjs/add/operator/map';\n            import 'rxjs/add/operator/toPromise';\n        ";
        return result;
    };
    AngularGenerator.prototype.getOptions = function () {
        var result = "\n            @Injectable()\n            export class ApiOptions {\n                public basePath: string = '';\n                public loginUrl: string;\n            }";
        return result;
    };
    AngularGenerator.prototype.getBaseClass = function (config) {
        var returnType = config.usePromises ? 'Promise<T>' : 'Observable<T>';
        var toPromise = config.usePromises ? '.toPromise()' : '';
        var result = "\n            @Injectable()\n            export abstract class BaseApi {\n                private dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*/\n\n                constructor(public http: Http, public options: ApiOptions) {\n                    this.reviver = this.reviver.bind(this);\n                }\n\n                protected request<T>(path: string, method: string, urlParams?: any, body?: any): " + returnType + " {\n                    let url = path;\n                    let search = new URLSearchParams();\n\n                    if (urlParams != undefined) {\n                        Object.getOwnPropertyNames(urlParams).forEach((paramName) => {\n                            if (url.indexOf(" + "`{${paramName}}`" + ") != -1) {\n                                url = url.replace(" + "`{${paramName}}`" + ", urlParams[paramName]);\n                            }\n                            else {\n                                this.addSearchParam(search, paramName, urlParams[paramName]);\n                            }\n                        });\n                    }\n\n                    if (body != undefined) {\n                        Object.getOwnPropertyNames(body).forEach((paramName) => {\n                            this.addSearchParam(search, paramName, body[paramName]);\n                        });\n                    }                    \n\n                    let request = this.http.request(this.options.basePath + url, {\n                        method: method,\n                        search: search\n                    });\n\n                    return request\n                        .map(x => {\n                            if (this.isJsonResponse(x)) {\n                                return this.parseJson(x.text());\n                            }\n\n                            if (x.ok) {\n                                return null;\n                            }\n\n                            return x.text();\n                        })\n                        .catch(x => {\n                            if (this.isJsonResponse(x)) {\n                                throw this.parseJson(x.text()).message;\n                            }\n\n                            throw x.text() || x.statusText;\n                        })                        \n                        " + toPromise + ";\n                }\n\n                private isJsonResponse(response: any): boolean {\n                    let contentType = response.headers.get(\"content-type\");\n\n                    if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                private parseJson(text: string): any {\n                    return JSON.parse(text, this.reviver);\n                }\n\n                private reviver(key, value) {\n                    if (typeof value === \"string\" && this.dateFormat.test(value)) {\n                        return new Date(value);\n                    }\n\n                    return value;\n                }\n\n                private addSearchParam(search: URLSearchParams, name: string, value: any): void {\n                    if (value instanceof Array) {\n                        value.forEach((v, i) => {\n                            this.addSearchParam(search, " + "`${name}[${i}]`" + ", v);\n                        });\n                    } else {\n                        if (value instanceof Date) {\n                            search.append(name, value.toUTCString());\n                        } else {\n                            if (value instanceof Object) {\n                                Object.getOwnPropertyNames(value).forEach((propertyName) => {\n                                    this.addSearchParam(search, " + "`${name}.${propertyName}`" + ", value[propertyName]);\n                                });\n                            }\n                            else {\n                                search.append(name, value);\n                            }\n                        }\n                    }\n                }\n            }";
        return result;
    };
    AngularGenerator.prototype.getController = function (controller, config) {
        var operations = [];
        if (controller.operations != undefined) {
            for (var _i = 0, _a = controller.operations; _i < _a.length; _i++) {
                var operation = _a[_i];
                operations.push(this.getOperation(operation, config));
            }
        }
        var result = "\n            @Injectable()\n            export class " + controller.name + "Api extends BaseApi {\n                " + operations.join('') + "\n            }";
        return result;
    };
    AngularGenerator.prototype.getOperation = function (operation, config) {
        var path = operation.path;
        var method = operation.method;
        var urlParams = '';
        var bodyParam = undefined;
        var name = this.camelCase(operation.name);
        var returnTypeArgument = this.mapType(operation.responseType);
        var returnType = config.usePromises ? "Promise<" + returnTypeArgument + ">" : "Observable<" + returnTypeArgument + ">";
        var parameters = [];
        if (operation.parameters != undefined) {
            for (var _i = 0, _a = operation.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                var source = parameter.in.toLowerCase();
                if (source == 'body') {
                    bodyParam = parameter.name;
                }
                if (source == 'query' || source == 'path') {
                    if (urlParams.length > 0) {
                        urlParams += ', ';
                    }
                    urlParams += parameter.name + ": " + parameter.name;
                }
                parameters.push(this.getOperationParameter(parameter));
            }
        }
        var requestParameters = "'" + path + "', '" + method + "'";
        if (urlParams.length > 0 || bodyParam != undefined) {
            requestParameters += ", { " + urlParams + " }";
        }
        if (bodyParam != undefined) {
            requestParameters += ", " + bodyParam;
        }
        var operationMethod = "\n            public " + name + "(" + parameters.join() + "): " + returnType + " {\n                return this.request<" + returnTypeArgument + ">(" + requestParameters + ");\n            }\n        ";
        if (operation.summary) {
            operationMethod = "/** " + operation.summary + " */ " + operationMethod;
        }
        return operationMethod;
    };
    AngularGenerator.prototype.getOperationParameter = function (operationParameter) {
        var parameter = operationParameter.name;
        var parameterType = this.mapType(operationParameter.type);
        parameter += ": " + parameterType;
        if (!operationParameter.required) {
            var defaultValue = operationParameter.default;
            if (defaultValue == undefined) {
                parameter += " = undefined";
            }
            else {
                if (parameterType == 'string') {
                    defaultValue = "'" + defaultValue + "'";
                }
                parameter += " = " + defaultValue;
            }
        }
        return parameter;
    };
    AngularGenerator.prototype.getSchema = function (schema) {
        if (schema.type == specification_1.SchemaType.Enumeration) {
            return this.getEnum(schema);
        }
        return this.getInterface(schema);
    };
    AngularGenerator.prototype.getEnum = function (schema) {
        var values = [];
        if (schema.values != undefined) {
            for (var _i = 0, _a = schema.values; _i < _a.length; _i++) {
                var enumValue = _a[_i];
                if (enumValue.value != undefined) {
                    values.push(enumValue.name + " = " + enumValue.value);
                }
                else {
                    values.push(enumValue.name);
                }
            }
        }
        var result = "\n            export enum " + schema.name + " {\n                " + values.join(', \n') + "\n            }";
        return result;
    };
    AngularGenerator.prototype.getInterface = function (schema) {
        var _this = this;
        var base = '';
        var properties = [];
        if (schema.extends != undefined) {
            base = "extends " + schema.extends.map(function (x) { return _this.mapType(x); }).join(', ');
        }
        if (schema.properties != undefined) {
            for (var _i = 0, _a = schema.properties; _i < _a.length; _i++) {
                var property = _a[_i];
                var propertyName = this.camelCase(property.name);
                var propertyType = this.mapType(property.type);
                if (property.nullable) {
                    propertyName += '?';
                }
                properties.push(propertyName + ": " + propertyType + ";");
            }
        }
        var result = "\n            export interface " + schema.name + " " + base + " {\n                " + properties.join('\n') + "\n            }";
        return result;
    };
    AngularGenerator.prototype.mapType = function (coreType) {
        // collection;
        var _this = this;
        if (coreType.endsWith('[]')) {
            var collectionType = this.mapType(coreType.substr(0, coreType.length - 2));
            return collectionType + "[]";
        }
        // generic type;
        if (coreType.endsWith('>')) {
            var genericType = this.parseGenericType(coreType);
            var genericArguments = genericType.arguments
                .map(function (x) { return _this.mapType(x); })
                .join(', ');
            return genericType.name + "<" + genericArguments + ">";
        }
        // primitive;
        switch (coreType.toLowerCase()) {
            case 'guid':
            case 'string':
                return 'string';
            case 'datetime':
                return 'Date';
            case 'bool':
            case 'boolean':
                return 'boolean';
            case 'byte':
            case 'short':
            case 'int':
            case 'integer':
            case 'int16':
            case 'int32':
            case 'int64':
            case 'float':
            case 'decimal':
            case 'double':
            case 'single':
                return 'number';
            case 'void':
                return 'void';
            case 'object':
                return 'any';
            default:
                break;
        }
        // interface;
        return coreType;
    };
    AngularGenerator.prototype.parseGenericType = function (typeName) {
        var open = typeName.indexOf('<');
        var genericName = typeName.substr(0, open);
        var genericArguments = [];
        var splitters;
        var level = 0;
        var buf = '';
        for (var i = open + 1; i < typeName.length - 1; i++) {
            var c = typeName[i];
            if (c == '<') {
                level++;
            }
            else if (c == '>') {
                level--;
            }
            else if (c == ',' && level == 0) {
                genericArguments.push(buf.trim());
                buf = '';
            }
            if (c != ',' || level > 0) {
                buf += c;
            }
        }
        genericArguments.push(buf.trim());
        return { arguments: genericArguments, name: genericName };
    };
    AngularGenerator.prototype.camelCase = function (text) {
        return text.substr(0, 1).toLowerCase() + text.substr(1);
    };
    return AngularGenerator;
}());
exports.AngularGenerator = AngularGenerator;
//     private getApi(apiDescription: ApiDescription, config: GeneratorConfig): string {
//         let fields: string[] = [];
//         let properties: string[] = [];
//         if (apiDescription.controllers != undefined) {
//             apiDescription.controllers.forEach((controller) => {
//                 var className = controller.name + 'Controller'; 
//                 var fieldName = '_' + this.camelCase(controller.name);
//                 fields.push(`private ${fieldName}: ${className};`);
//                 var property = `public get ${this.camelCase(controller.name)}(): ${className} {
//                         if (this.${fieldName} == undefined) {
//                             this.${fieldName} = new ${className}(this._connection);
//                         }
//                         return this.${fieldName};
//                     }`;
//                 properties.push(property);
//             });
//         }
//         return `
//             @Injectable()
//             export class ${config.outputClass} {
//                 private _connection: ApiConnection;
//                 ${fields.join('\n')}
//                 constructor (http: Http) {
//                     this._connection = new ApiConnection(http, '');
//                 }
//                 public get basePath(): string {
//                     return this._connection.basePath;
//                 }
//                 public set basePath(basePath: string) {
//                     this._connection.basePath = basePath;
//                 }
//                 ${properties.join('\n')}
//             }`;
//     }
//# sourceMappingURL=angular-generator.js.map